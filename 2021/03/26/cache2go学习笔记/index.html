<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tinybeer.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="​        cache2go作为一个入门级别的开源项目。cache2go 是一个 Go 的并发安全缓存库，具有到期和访问计数器的功能。带有失效性的单机缓存机制。cache2go代码简单，非常适合新手学习。">
<meta property="og:type" content="article">
<meta property="og:title" content="cache2go学习笔记">
<meta property="og:url" content="https://tinybeer.github.io/2021/03/26/cache2go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="困">
<meta property="og:description" content="​        cache2go作为一个入门级别的开源项目。cache2go 是一个 Go 的并发安全缓存库，具有到期和访问计数器的功能。带有失效性的单机缓存机制。cache2go代码简单，非常适合新手学习。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-25T16:43:29.000Z">
<meta property="article:modified_time" content="2021-03-25T16:45:07.741Z">
<meta property="article:author" content="Tiny Beer">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tinybeer.github.io/2021/03/26/cache2go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>cache2go学习笔记 | 困</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">困</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>Schedule</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RpbnlCZWVy" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://tinybeer.github.io/2021/03/26/cache2go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img.imgdb.cn/item/6048d2685aedab222c85ee27.jpg">
      <meta itemprop="name" content="Tiny Beer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="困">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cache2go学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-03-26 00:43:29 / Modified: 00:45:07" itemprop="dateCreated datePublished" datetime="2021-03-26T00:43:29+08:00">2021-03-26</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>16 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>​        cache2go作为一个入门级别的开源项目。cache2go 是一个 Go 的并发安全缓存库，具有到期和访问计数器的功能。带有失效性的单机缓存机制。cache2go代码简单，非常适合新手学习。</p>
<span id="more"></span>

<h1 id="1-克隆项目"><a href="#1-克隆项目" class="headerlink" title="1.克隆项目"></a>1.克隆项目</h1><p>项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL211ZXNsaS9jYWNoZTJnbw==" title="https://github.com/muesli/cache2go">https://github.com/muesli/cache2go<i class="fa fa-external-link"></i></span></p>
<p>使用git clone指令即可。</p>
<h1 id="2-运行样例"><a href="#2-运行样例" class="headerlink" title="2.运行样例"></a>2.运行样例</h1><p>​        将代码clone到喜欢的文件夹后，计入文件夹查看README.md文件。根据其中的提示，使用go run 执行mycachedapp.go文件。循行正常，可以看到如下结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go run .\examples\mycachedapp\mycachedapp.go</span><br><span class="line">Found value in cache: This is a test!</span><br><span class="line">Item is not cached (anymore).</span><br><span class="line">Deleting: someKey This is a test! 2021-03-18 23:55:05.8153461 +0800 CST m&#x3D;+6.004047501</span><br></pre></td></tr></table></figure>

<p>对照输出结果查看元mycachedapp代码。</p>
<p>​            首先是引包。可以看到，样例共使用了三个包。其中<code>fmt</code> <code>time</code> 为官方提供的包，很熟悉了。<code>cache2go</code>为cache2go正是为我们要学习的包，可以暂且不管。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/muesli/cache2go&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>​            第二部分是一个结构体类型的声明，包含text string类型，moreData byte切片两个字段。上方注释说，在cache2go中，键和值可以是任意类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keys &amp; values in cache2go can be of arbitrary types, e.g. a struct.</span></span><br><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  text     <span class="keyword">string</span></span><br><span class="line">  moreData []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        最后就是主函数了。粗略浏览一番。大概执行流程如下:</p>
<ol>
<li>获取一个缓存表实例     在第一次访问一个新的缓存表时将会创建它。</li>
<li>创建一个myStruct实例val，text字段填入 <code>This is  a test!</code>， moreData字段填入空字节切片。</li>
<li>将刚创建的结构体实例送入cache中，设置键名为 <code>somekey</code> ，超时时间为5秒，使用指针传递结构体。</li>
<li>从缓存中获取key为<code>somekey</code>的值，返回res和err，根据err不同输出不同的提示。</li>
<li>延时6秒，重复4的操作。</li>
<li>再次将val加入到缓存中，超时时间内使用0，表示永不失效。</li>
<li>为缓存注册一个删除时触发的回调函数，打印出删除报告，包括被删除键的信息。</li>
<li>删除cache中键为somekey的元素。</li>
<li>最后清理缓存。</li>
</ol>
<p>​        代码大致意思搞懂就行了，应该没有什么障碍。大致了解流程后，就可以结合输出捋一捋代码实现的功能是否和我们理解的一样。也可以尝试修改一些地方看看，能不能达到自己想要的效果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Accessing a new cache table for the first time will create it.</span></span><br><span class="line">  cache := cache2go.Cache(<span class="string">&quot;myCache&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will put a new item in the cache. It will expire after</span></span><br><span class="line">  <span class="comment">// not being accessed via Value(key) for more than 5 seconds.</span></span><br><span class="line">  val := myStruct&#123;<span class="string">&quot;This is a test!&quot;</span>, []<span class="keyword">byte</span>&#123;&#125;&#125;</span><br><span class="line">  cache.Add(<span class="string">&quot;someKey&quot;</span>, <span class="number">5</span>*time.Second, &amp;val)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Let&#x27;s retrieve the item from the cache.</span></span><br><span class="line">  res, err := cache.Value(<span class="string">&quot;someKey&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Found value in cache:&quot;</span>, res.Data().(*myStruct).text)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error retrieving value from cache:&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for the item to expire in cache.</span></span><br><span class="line">  time.Sleep(<span class="number">6</span> * time.Second)</span><br><span class="line">  res, err = cache.Value(<span class="string">&quot;someKey&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Item is not cached (anymore).&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add another item that never expires.</span></span><br><span class="line">  cache.Add(<span class="string">&quot;someKey&quot;</span>, <span class="number">0</span>, &amp;val)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cache2go supports a few handy callbacks and loading mechanisms.</span></span><br><span class="line">  cache.SetAboutToDeleteItemCallback(<span class="function"><span class="keyword">func</span><span class="params">(e *cache2go.CacheItem)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Deleting:&quot;</span>, e.Key(), e.Data().(*myStruct).text, e.CreatedOn())</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the item from the cache.</span></span><br><span class="line">  cache.Delete(<span class="string">&quot;someKey&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// And wipe the entire cache table.</span></span><br><span class="line">  cache.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-开始啃源码"><a href="#3-开始啃源码" class="headerlink" title="3.开始啃源码"></a>3.开始啃源码</h1><p>​        可以看到，样例代码中所有的操作都围绕者cache展开，也就是我们的缓存表。不妨就从这里开始吧。追踪<code>cache2go.Cache(&quot;myCache&quot;)</code>函数。这个函数返回一个已经存在的cache表或者表不存在时创建一个(单例模式)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cache returns the existing cache table with given name or creates a new one</span></span><br><span class="line"><span class="comment">// if the table does not exist yet.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cache</span><span class="params">(table <span class="keyword">string</span>)</span> *<span class="title">CacheTable</span></span> </span><br></pre></td></tr></table></figure>

<h2 id="CacheTable类"><a href="#CacheTable类" class="headerlink" title="CacheTable类"></a>CacheTable类</h2><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>可以看到CacheTable是一个结构体。字段如下：</p>
<ul>
<li>读写锁</li>
<li>name 表名</li>
<li>items 存放缓存元素的map</li>
<li>cleanupTimer 用于触发清理的定时器</li>
<li>clearnupInterval 当前时间</li>
<li>logger 用于答应信息的logger</li>
<li>loadData 加载不存在数据时触发的回调函数的切片</li>
<li>addedItem 先缓存中加入新元素时触发的回调函数的切片</li>
<li>aboutToDeleteItem 删除元素之前触发的回调函数的切片</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CacheTable is a table within the cache</span></span><br><span class="line"><span class="keyword">type</span> CacheTable <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.RWMutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The table&#x27;s name.</span></span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">  <span class="comment">// All cached items.</span></span><br><span class="line">  items <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Timer responsible for triggering cleanup.</span></span><br><span class="line">  cleanupTimer *time.Timer</span><br><span class="line">  <span class="comment">// Current timer duration.</span></span><br><span class="line">  cleanupInterval time.Duration</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The logger used for this table.</span></span><br><span class="line">  logger *log.Logger</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Callback method triggered when trying to load a non-existing key.</span></span><br><span class="line">  loadData <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span></span><br><span class="line">  <span class="comment">// Callback method triggered when adding a new item to the cache.</span></span><br><span class="line">  addedItem []<span class="function"><span class="keyword">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line">  <span class="comment">// Callback method triggered before deleting an item from the cache.</span></span><br><span class="line">  aboutToDeleteItem []<span class="function"><span class="keyword">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Count方法"><a href="#Count方法" class="headerlink" title="Count方法"></a>Count方法</h3><p>获取缓存表中键值对的数量，使用读锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count returns how many items are currently stored in the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  table.RLock()</span><br><span class="line">  <span class="keyword">defer</span> table.RUnlock()</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(table.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Foreach方法"><a href="#Foreach方法" class="headerlink" title="*Foreach方法"></a>*Foreach方法</h3><p>对缓存表中所有方法执行trans函数，函数参数key，item。使用读锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foreach all items</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Foreach</span><span class="params">(trans <span class="keyword">func</span>(key <span class="keyword">interface</span>&#123;&#125;, item *CacheItem)</span>)</span> &#123;</span><br><span class="line">  table.RLock()</span><br><span class="line">  <span class="keyword">defer</span> table.RUnlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> table.items &#123;</span><br><span class="line">    trans(k, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SetDataLoader方法"><a href="#SetDataLoader方法" class="headerlink" title="*SetDataLoader方法"></a>*SetDataLoader方法</h3><p>批量设置数据加载不存在键值对时触发的回调函数，使用写锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetDataLoader configures a data-loader callback, which will be called when</span></span><br><span class="line"><span class="comment">// trying to access a non-existing key. The key and 0...n additional arguments</span></span><br><span class="line"><span class="comment">// are passed to the callback function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">SetDataLoader</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;, ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span>)</span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">  table.loadData = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SetAddedItemCallback方法"><a href="#SetAddedItemCallback方法" class="headerlink" title="SetAddedItemCallback方法"></a>SetAddedItemCallback方法</h3><p>设置新元素加载完成后触发的回调函数。如过已经存在，则使用RemoveAddedItemCallbacks方法清空后再添加。使用写锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAddedItemCallback configures a callback, which will be called every time</span></span><br><span class="line"><span class="comment">// a new item is added to the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">SetAddedItemCallback</span><span class="params">(f <span class="keyword">func</span>(*CacheItem)</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(table.addedItem) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    table.RemoveAddedItemCallbacks()</span><br><span class="line">  &#125;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">  table.addedItem = <span class="built_in">append</span>(table.addedItem, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AddAddedItemCallback方法"><a href="#AddAddedItemCallback方法" class="headerlink" title="AddAddedItemCallback方法"></a>AddAddedItemCallback方法</h3><p>添加新元素加载完成后触发的回调函数。使用写锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AddAddedItemCallback appends a new callback to the addedItem queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">AddAddedItemCallback</span><span class="params">(f <span class="keyword">func</span>(*CacheItem)</span>)</span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">  table.addedItem = <span class="built_in">append</span>(table.addedItem, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RemoveAddedItemCallbacks方法"><a href="#RemoveAddedItemCallbacks方法" class="headerlink" title="RemoveAddedItemCallbacks方法"></a>RemoveAddedItemCallbacks方法</h3><p>移除所有新元素加载完成后触发的回调函数。使用写锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveAddedItemCallbacks empties the added item callback queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">RemoveAddedItemCallbacks</span><span class="params">()</span></span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">  table.addedItem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SetAboutToDeleteItemCallback方法"><a href="#SetAboutToDeleteItemCallback方法" class="headerlink" title="SetAboutToDeleteItemCallback方法"></a>SetAboutToDeleteItemCallback方法</h3><p>设置元素删除时触发的回调函数。如过已经存在，则使用RemoveAboutToDeleteItemCallback方法清空后再添加。使用写锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAboutToDeleteItemCallback configures a callback, which will be called</span></span><br><span class="line"><span class="comment">// every time an item is about to be removed from the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">SetAboutToDeleteItemCallback</span><span class="params">(f <span class="keyword">func</span>(*CacheItem)</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(table.aboutToDeleteItem) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    table.RemoveAboutToDeleteItemCallback()</span><br><span class="line">  &#125;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">  table.aboutToDeleteItem = <span class="built_in">append</span>(table.aboutToDeleteItem, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AddAboutToDeleteItemCallback方法"><a href="#AddAboutToDeleteItemCallback方法" class="headerlink" title="AddAboutToDeleteItemCallback方法"></a>AddAboutToDeleteItemCallback方法</h3><p>添加元素删除时触发的回调函数。使用写锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddAboutToDeleteItemCallback appends a new callback to the AboutToDeleteItem queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">AddAboutToDeleteItemCallback</span><span class="params">(f <span class="keyword">func</span>(*CacheItem)</span>)</span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">  table.aboutToDeleteItem = <span class="built_in">append</span>(table.aboutToDeleteItem, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="RemoveAboutToDeleteItemCallback方法"><a href="#RemoveAboutToDeleteItemCallback方法" class="headerlink" title="RemoveAboutToDeleteItemCallback方法"></a>RemoveAboutToDeleteItemCallback方法</h3><p>移除所有元素删除时触发的回调函数。使用写锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveAboutToDeleteItemCallback empties the about to delete item callback queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">RemoveAboutToDeleteItemCallback</span><span class="params">()</span></span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">  table.aboutToDeleteItem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置日志记录器，使用策略模式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetLogger sets the logger to be used by this cache table.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">SetLogger</span><span class="params">(logger *log.Logger)</span></span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">  table.logger = logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="expirationCheck方法"><a href="#expirationCheck方法" class="headerlink" title="*expirationCheck方法"></a>*expirationCheck方法</h3><p>超期检测循环，有一个自校准定时器触发。核心方法之一。</p>
<p>流程</p>
<ol>
<li>加写锁</li>
<li>停止定时器</li>
<li>检擦是否注册了超期检测时钟，如果注册了，记录日志还有多久将进行清除检测。如果没有，记录日志，进行清除检测注册。</li>
<li>校准当前时间。提高计时精度。</li>
<li>遍历缓存表，使用now.Sub(accessedOn) &gt;= lifeSpan作为判断依据判断元素是否超期，超期则调用deleteInternal方法删除元素。同时找出未超期元素中，距离超期时间最短的一个(存在一定的误差)。</li>
<li>如果最短超期时间大于0，注册定时器，超期时候触发协程，调用expirationCheck方法进行检测。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expiration check loop, triggered by a self-adjusting timer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">expirationCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">if</span> table.cleanupTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">    table.cleanupTimer.Stop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> table.cleanupInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">    table.log(<span class="string">&quot;Expiration check triggered after&quot;</span>, table.cleanupInterval, <span class="string">&quot;for table&quot;</span>, table.name)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    table.log(<span class="string">&quot;Expiration check installed for table&quot;</span>, table.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// To be more accurate with timers, we would need to update &#x27;now&#x27; on every</span></span><br><span class="line">  <span class="comment">// loop iteration. Not sure it&#x27;s really efficient though.</span></span><br><span class="line">  now := time.Now()</span><br><span class="line">  smallestDuration := <span class="number">0</span> * time.Second</span><br><span class="line">  <span class="keyword">for</span> key, item := <span class="keyword">range</span> table.items &#123;</span><br><span class="line">    <span class="comment">// Cache values so we don&#x27;t keep blocking the mutex.</span></span><br><span class="line">    item.RLock()</span><br><span class="line">    lifeSpan := item.lifeSpan</span><br><span class="line">    accessedOn := item.accessedOn</span><br><span class="line">    item.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lifeSpan == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> now.Sub(accessedOn) &gt;= lifeSpan &#123;</span><br><span class="line">      <span class="comment">// Item has excessed its lifespan.</span></span><br><span class="line">      table.deleteInternal(key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Find the item chronologically closest to its end-of-lifespan.</span></span><br><span class="line">      <span class="keyword">if</span> smallestDuration == <span class="number">0</span> || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration &#123;</span><br><span class="line">        smallestDuration = lifeSpan - now.Sub(accessedOn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setup the interval for the next cleanup run.</span></span><br><span class="line">  table.cleanupInterval = smallestDuration</span><br><span class="line">  <span class="keyword">if</span> smallestDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">    table.cleanupTimer = time.AfterFunc(smallestDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">go</span> table.expirationCheck()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  table.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addInternalf方法"><a href="#addInternalf方法" class="headerlink" title="*addInternalf方法"></a>*addInternalf方法</h3><p>为缓存表添加元素。必须在加写锁状态下执行，因为方法内进行了解锁操作。方法执行流程：</p>
<p>1.触发日志，记录添加元素的信息。</p>
<p>2.记录清理间隔时间和添加元素时触发的回调函数，然后解除写锁。</p>
<p>3.执行所有已经注册的回调函数。</p>
<p>4.如果新元素有超期时间，并且缓存表还未注册定时器或新元素生命周期短于超期间隔，则执行超期检测方法。expirationCheck</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">addInternal</span><span class="params">(item *CacheItem)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Careful: do not run this method unless the table-mutex is locked!</span></span><br><span class="line">  <span class="comment">// It will unlock it for the caller before running the callbacks and checks</span></span><br><span class="line">  table.log(<span class="string">&quot;Adding item with key&quot;</span>, item.key, <span class="string">&quot;and lifespan of&quot;</span>, item.lifeSpan, <span class="string">&quot;to table&quot;</span>, table.name)</span><br><span class="line">  table.items[item.key] = item</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cache values so we don&#x27;t keep blocking the mutex.</span></span><br><span class="line">  expDur := table.cleanupInterval</span><br><span class="line">  addedItem := table.addedItem</span><br><span class="line">  table.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger callback after adding an item to cache.</span></span><br><span class="line">  <span class="keyword">if</span> addedItem != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, callback := <span class="keyword">range</span> addedItem &#123;</span><br><span class="line">      callback(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we haven&#x27;t set up any expiration check timer or found a more imminent item.</span></span><br><span class="line">  <span class="keyword">if</span> item.lifeSpan &gt; <span class="number">0</span> &amp;&amp; (expDur == <span class="number">0</span> || item.lifeSpan &lt; expDur) &#123;</span><br><span class="line">    table.expirationCheck()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Add方法"><a href="#Add方法" class="headerlink" title="Add方法"></a>Add方法</h3><p>向缓存表中添加元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add adds a key/value pair to the cache.</span></span><br><span class="line"><span class="comment">// Parameter key is the item&#x27;s cache-key.</span></span><br><span class="line"><span class="comment">// Parameter lifeSpan determines after which time period without an access the item</span></span><br><span class="line"><span class="comment">// will get removed from the cache.</span></span><br><span class="line"><span class="comment">// Parameter data is the item&#x27;s value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;</span><br><span class="line">  item := NewCacheItem(key, lifeSpan, data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add item to cache.</span></span><br><span class="line">  table.Lock()</span><br><span class="line">  table.addInternal(item)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="deleteInternal方法"><a href="#deleteInternal方法" class="headerlink" title="*deleteInternal方法"></a>*deleteInternal方法</h3><p>删除CacheItem元素，需要在缓存表加写锁状态下执行。方法流程</p>
<ol>
<li>获取键对应CacheItem元素，判断是否存在，不存在则返回错误</li>
<li>记录删除回调函数 ，并解锁。</li>
<li>执行删除回调函数。</li>
<li>给CacheItem元素上读锁，延迟解除读锁。</li>
<li>检查元素是否有超期回调函数，有责执行。</li>
<li>给表上写锁，触发日志记录，记录删除元素信息。</li>
<li>删除元素。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">deleteInternal</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">  r, ok := table.items[key]</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cache value so we don&#x27;t keep blocking the mutex.</span></span><br><span class="line">  aboutToDeleteItem := table.aboutToDeleteItem</span><br><span class="line">  table.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger callbacks before deleting an item from cache.</span></span><br><span class="line">  <span class="keyword">if</span> aboutToDeleteItem != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, callback := <span class="keyword">range</span> aboutToDeleteItem &#123;</span><br><span class="line">      callback(r)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  r.RLock()</span><br><span class="line">  <span class="keyword">defer</span> r.RUnlock()</span><br><span class="line">  <span class="keyword">if</span> r.aboutToExpire != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, callback := <span class="keyword">range</span> r.aboutToExpire &#123;</span><br><span class="line">      callback(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  table.Lock()</span><br><span class="line">  table.log(<span class="string">&quot;Deleting item with key&quot;</span>, key, <span class="string">&quot;created on&quot;</span>, r.createdOn, <span class="string">&quot;and hit&quot;</span>, r.accessCount, <span class="string">&quot;times from table&quot;</span>, table.name)</span><br><span class="line">  <span class="built_in">delete</span>(table.items, key)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete方法"><a href="#Delete方法" class="headerlink" title="Delete方法"></a>Delete方法</h3><p>调用deleteInternal方法删除CacheItem，返回被删除元素指针，和错误信息。使用写锁保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete an item from the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> table.deleteInternal(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exists方法"><a href="#Exists方法" class="headerlink" title="Exists方法"></a>Exists方法</h3><p>判断对应key的CacheItem是否存在，使用读锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exists returns whether an item exists in the cache. Unlike the Value method</span></span><br><span class="line"><span class="comment">// Exists neither tries to fetch data via the loadData callback nor does it</span></span><br><span class="line"><span class="comment">// keep the item alive in the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Exists</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  table.RLock()</span><br><span class="line">  <span class="keyword">defer</span> table.RUnlock()</span><br><span class="line">  _, ok := table.items[key]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NotFoundAdd方法"><a href="#NotFoundAdd方法" class="headerlink" title="NotFoundAdd方法"></a>NotFoundAdd方法</h3><p>判断是否存在对应key的CaacheItem，如果存在返回false，不存在添加CacheItem并返回true。使用写锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NotFoundAdd checks whether an item is not yet cached. Unlike the Exists</span></span><br><span class="line"><span class="comment">// method this also adds data if the key could not be found.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">NotFoundAdd</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _, ok := table.items[key]; ok &#123;</span><br><span class="line">    table.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  item := NewCacheItem(key, lifeSpan, data)</span><br><span class="line">  table.addInternal(item)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Value方法"><a href="#Value方法" class="headerlink" title="Value方法"></a>Value方法</h3><p>根据key获取CacheItem，刷新超期时间。如果CacheItem不存在，触发loadData函数，可以为loadData传入参数。如果CacheItem不存在，会根据情况返回错误信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value returns an item from the cache and marks it to be kept alive. You can</span></span><br><span class="line"><span class="comment">// pass additional arguments to your DataLoader callback function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">  table.RLock()</span><br><span class="line">  r, ok := table.items[key]</span><br><span class="line">  loadData := table.loadData</span><br><span class="line">  table.RUnlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    <span class="comment">// Update access counter and timestamp.</span></span><br><span class="line">    r.KeepAlive()</span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Item doesn&#x27;t exist in cache. Try and fetch it with a data-loader.</span></span><br><span class="line">  <span class="keyword">if</span> loadData != <span class="literal">nil</span> &#123;</span><br><span class="line">    item := loadData(key, args...)</span><br><span class="line">    <span class="keyword">if</span> item != <span class="literal">nil</span> &#123;</span><br><span class="line">      table.Add(key, item.lifeSpan, item.data)</span><br><span class="line">      <span class="keyword">return</span> item, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFoundOrLoadable</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Flush方法"><a href="#Flush方法" class="headerlink" title="Flush方法"></a>Flush方法</h3><p>刷新缓存表，清除表中所有数据。使用写锁保护。会重置清除间隔时间，停止定时器，记录日志。但不会清理已经注册的回调函数。数据清空使用新建map方式，让GC自动回收原来的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flush deletes all items from this cache table.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Flush</span><span class="params">()</span></span> &#123;</span><br><span class="line">  table.Lock()</span><br><span class="line">  <span class="keyword">defer</span> table.Unlock()</span><br><span class="line"></span><br><span class="line">  table.log(<span class="string">&quot;Flushing table&quot;</span>, table.name)</span><br><span class="line"></span><br><span class="line">  table.items = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem)</span><br><span class="line">  table.cleanupInterval = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> table.cleanupTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">    table.cleanupTimer.Stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MostAccessed方法"><a href="#MostAccessed方法" class="headerlink" title="*MostAccessed方法"></a>*MostAccessed方法</h3><p>获取热点CacheItem列表，使用sort.sort方法实现。采用读锁进行数据保护。实现方法:</p>
<p>声明CacheItemPair和CacheItemPairList结构体，为CacheItemPairList实现sort.Interface接口，是之可以调用Sort方法。具体步骤：</p>
<ol>
<li>对缓存表加读锁，延迟解锁。</li>
<li>拷贝所有的key和访问次数，存入CacheItemPairList中</li>
<li>对CacheItemPairList进行由大到小排序。</li>
<li>遍历CacheItemPairList，取出所有访问次数大于c的key，根据key构建 r []*CacheItem。</li>
<li>返回r</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CacheItemPair maps key to access counter</span></span><br><span class="line"><span class="keyword">type</span> CacheItemPair <span class="keyword">struct</span> &#123;</span><br><span class="line">  Key         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  AccessCount <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CacheItemPairList is a slice of CacheItemPairs that implements sort.</span></span><br><span class="line"><span class="comment">// Interface to sort by AccessCount.</span></span><br><span class="line"><span class="keyword">type</span> CacheItemPairList []CacheItemPair</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i].AccessCount &gt; p[j].AccessCount &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MostAccessed returns the most accessed items in this cache table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">MostAccessed</span><span class="params">(count <span class="keyword">int64</span>)</span> []*<span class="title">CacheItem</span></span> &#123;</span><br><span class="line">  table.RLock()</span><br><span class="line">  <span class="keyword">defer</span> table.RUnlock()</span><br><span class="line"></span><br><span class="line">  p := <span class="built_in">make</span>(CacheItemPairList, <span class="built_in">len</span>(table.items))</span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> table.items &#123;</span><br><span class="line">    p[i] = CacheItemPair&#123;k, v.accessCount&#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  sort.Sort(p)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> r []*CacheItem</span><br><span class="line">  c := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> p &#123;</span><br><span class="line">    <span class="keyword">if</span> c &gt;= count &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item, ok := table.items[v.Key]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">      r = <span class="built_in">append</span>(r, item)</span><br><span class="line">    &#125;</span><br><span class="line">    c++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="log方法"><a href="#log方法" class="headerlink" title="log方法"></a>log方法</h3><p>打印log自定义的log信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal logging method for convenience.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">log</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> table.logger == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  table.logger.Println(v...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CacheItem类"><a href="#CacheItem类" class="headerlink" title="CacheItem类"></a>CacheItem类</h2><h3 id="类结构-1"><a href="#类结构-1" class="headerlink" title="类结构"></a>类结构</h3><ul>
<li>读写锁</li>
<li>key 键，接口类型 任意类型</li>
<li>data 数据，接口类型 任意类型</li>
<li>lifeSpan 生命周期，存在时长</li>
<li>createdOn 创建时间</li>
<li>accessedOn 最后一次访问时间</li>
<li>accessCount 访问次数</li>
<li>aboutToExpire 过期是触发的函数切片</li>
</ul>
<p>至此已经没有不熟悉的类了。接下来就去看看与类绑定的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CacheItem is an individual cache item</span></span><br><span class="line"><span class="comment">// Parameter data contains the user-set value in the cache.</span></span><br><span class="line"><span class="keyword">type</span> CacheItem <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.RWMutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The item&#x27;s key.</span></span><br><span class="line">  key <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// The item&#x27;s data.</span></span><br><span class="line">  data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// How long will the item live in the cache when not being accessed/kept alive.</span></span><br><span class="line">  lifeSpan time.Duration</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creation timestamp.</span></span><br><span class="line">  createdOn time.Time</span><br><span class="line">  <span class="comment">// Last access timestamp.</span></span><br><span class="line">  accessedOn time.Time</span><br><span class="line">  <span class="comment">// How often the item was accessed.</span></span><br><span class="line">  accessCount <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Callback method triggered right before removing the item from the cache</span></span><br><span class="line">  aboutToExpire []<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewCacheItem函数"><a href="#NewCacheItem函数" class="headerlink" title="NewCacheItem函数"></a>NewCacheItem函数</h3><p>根据传入参数实例化一个CacheItem对象，并返回其指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewCacheItem returns a newly created CacheItem.</span></span><br><span class="line"><span class="comment">// Parameter key is the item&#x27;s cache-key.</span></span><br><span class="line"><span class="comment">// Parameter lifeSpan determines after which time period without an access the item</span></span><br><span class="line"><span class="comment">// will get removed from the cache.</span></span><br><span class="line"><span class="comment">// Parameter data is the item&#x27;s value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCacheItem</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;</span><br><span class="line">  t := time.Now()</span><br><span class="line">  <span class="keyword">return</span> &amp;CacheItem&#123;</span><br><span class="line">    key:           key,</span><br><span class="line">    lifeSpan:      lifeSpan,</span><br><span class="line">    createdOn:     t,</span><br><span class="line">    accessedOn:    t,</span><br><span class="line">    accessCount:   <span class="number">0</span>,</span><br><span class="line">    aboutToExpire: <span class="literal">nil</span>,</span><br><span class="line">    data:          data,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KeepAlive方法"><a href="#KeepAlive方法" class="headerlink" title="KeepAlive方法"></a>KeepAlive方法</h3><p>刷新CacheItem的最后一次访问时间，实现延长超时时间功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KeepAlive marks an item to be kept for another expireDuration period.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">KeepAlive</span><span class="params">()</span></span> &#123;</span><br><span class="line">  item.Lock()</span><br><span class="line">  <span class="keyword">defer</span> item.Unlock()</span><br><span class="line">  item.accessedOn = time.Now()</span><br><span class="line">  item.accessCount++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LifeSpan方法"><a href="#LifeSpan方法" class="headerlink" title="LifeSpan方法"></a>LifeSpan方法</h3><p>返回CacheItem的超时间隔，生命周期。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LifeSpan returns this item&#x27;s expiration duration.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">LifeSpan</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">  <span class="comment">// immutable</span></span><br><span class="line">  <span class="keyword">return</span> item.lifeSpan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AccessedOn方法"><a href="#AccessedOn方法" class="headerlink" title="AccessedOn方法"></a>AccessedOn方法</h3><p>返回CacheItem的最后一次访问时间，使用读锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AccessedOn returns when this item was last accessed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">AccessedOn</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">  item.RLock()</span><br><span class="line">  <span class="keyword">defer</span> item.RUnlock()</span><br><span class="line">  <span class="keyword">return</span> item.accessedOn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CreateOn方法"><a href="#CreateOn方法" class="headerlink" title="CreateOn方法"></a>CreateOn方法</h3><p>返回CacheItem的创建时间，由于不会被修改，不需要进行读写保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreatedOn returns when this item was added to the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">CreatedOn</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">  <span class="comment">// immutable</span></span><br><span class="line">  <span class="keyword">return</span> item.createdOn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AccessCount方法"><a href="#AccessCount方法" class="headerlink" title="AccessCount方法"></a>AccessCount方法</h3><p>返回CacheItem的被访问次数，使用读锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AccessCount returns how often this item has been accessed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">AccessCount</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">  item.RLock()</span><br><span class="line">  <span class="keyword">defer</span> item.RUnlock()</span><br><span class="line">  <span class="keyword">return</span> item.accessCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Key方法"><a href="#Key方法" class="headerlink" title="Key方法"></a>Key方法</h3><p>放回CacheItem的键名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Key returns the key of this cached item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">Key</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">// immutable</span></span><br><span class="line">  <span class="keyword">return</span> item.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Data方法"><a href="#Data方法" class="headerlink" title="Data方法"></a>Data方法</h3><p>放回CacheItem的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Data returns the value of this cached item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">Data</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">// immutable</span></span><br><span class="line">  <span class="keyword">return</span> item.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SetAboutToExpireCallback方法"><a href="#SetAboutToExpireCallback方法" class="headerlink" title="SetAboutToExpireCallback方法"></a>SetAboutToExpireCallback方法</h3><p>设置CacheItem超期回调函数，使用写锁进行保护。如果已经注册了回调函数，则使用RemoveAboutToExpireCallback方法移除所有已注册方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAboutToExpireCallback configures a callback, which will be called right</span></span><br><span class="line"><span class="comment">// before the item is about to be removed from the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">SetAboutToExpireCallback</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(item.aboutToExpire) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    item.RemoveAboutToExpireCallback()</span><br><span class="line">  &#125;</span><br><span class="line">  item.Lock()</span><br><span class="line">  <span class="keyword">defer</span> item.Unlock()</span><br><span class="line">  item.aboutToExpire = <span class="built_in">append</span>(item.aboutToExpire, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AddAboutToExpireCallback方法"><a href="#AddAboutToExpireCallback方法" class="headerlink" title="AddAboutToExpireCallback方法"></a>AddAboutToExpireCallback方法</h3><p>为CacheItem添加超期回调函数，使用写锁进行保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddAboutToExpireCallback appends a new callback to the AboutToExpire queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">AddAboutToExpireCallback</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">  item.Lock()</span><br><span class="line">  <span class="keyword">defer</span> item.Unlock()</span><br><span class="line">  item.aboutToExpire = <span class="built_in">append</span>(item.aboutToExpire, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RemoveAboutToExpireCallback方法"><a href="#RemoveAboutToExpireCallback方法" class="headerlink" title="RemoveAboutToExpireCallback方法"></a>RemoveAboutToExpireCallback方法</h3><p>移除所有CacheItem的超期回调函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveAboutToExpireCallback empties the about to expire callback queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">RemoveAboutToExpireCallback</span><span class="params">()</span></span> &#123;</span><br><span class="line">  item.Lock()</span><br><span class="line">  <span class="keyword">defer</span> item.Unlock()</span><br><span class="line">  item.aboutToExpire = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-test"><a href="#4-test" class="headerlink" title="4.test"></a>4.test</h1><p>benchmark_test.go 测试资源占用等信息</p>
<p>cache_test.go 测试个方法功能是否正常</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><p>并发条件下使用读写锁确保数据安全。确保后续代码不会执行修改删除的情况下加读锁即可。</p>
<p>可以使用方法切片注册多个回调函数。可以对回调函数合理的分割，提高代码质量。</p>
<p>工厂模式、策略模式等的正确使用可以提升代码的灵活性。</p>
<p>使用定时器迭代替代for循环。</p>
<p>time.Sleep(0)妙用：释放cpu权限。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/20/Redis%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" rel="prev" title="Redis深入学习">
      <i class="fa fa-chevron-left"></i> Redis深入学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/26/http%E4%B8%8Ehttps/" rel="next" title="http与https">
      http与https <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%85%8B%E9%9A%86%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.</span> <span class="nav-text">1.克隆项目</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%BF%90%E8%A1%8C%E6%A0%B7%E4%BE%8B"><span class="nav-number">2.</span> <span class="nav-text">2.运行样例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%BC%80%E5%A7%8B%E5%95%83%E6%BA%90%E7%A0%81"><span class="nav-number">3.</span> <span class="nav-text">3.开始啃源码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CacheTable%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">CacheTable类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.1.</span> <span class="nav-text">类结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Count%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">Count方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Foreach%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.3.</span> <span class="nav-text">*Foreach方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SetDataLoader%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.4.</span> <span class="nav-text">*SetDataLoader方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SetAddedItemCallback%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.5.</span> <span class="nav-text">SetAddedItemCallback方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AddAddedItemCallback%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.6.</span> <span class="nav-text">AddAddedItemCallback方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RemoveAddedItemCallbacks%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.7.</span> <span class="nav-text">RemoveAddedItemCallbacks方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SetAboutToDeleteItemCallback%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.8.</span> <span class="nav-text">SetAboutToDeleteItemCallback方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AddAboutToDeleteItemCallback%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.9.</span> <span class="nav-text">AddAboutToDeleteItemCallback方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RemoveAboutToDeleteItemCallback%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.10.</span> <span class="nav-text">RemoveAboutToDeleteItemCallback方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#expirationCheck%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.11.</span> <span class="nav-text">*expirationCheck方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addInternalf%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.12.</span> <span class="nav-text">*addInternalf方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Add%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.13.</span> <span class="nav-text">Add方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deleteInternal%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.14.</span> <span class="nav-text">*deleteInternal方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delete%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.15.</span> <span class="nav-text">Delete方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exists%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.16.</span> <span class="nav-text">Exists方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NotFoundAdd%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.17.</span> <span class="nav-text">NotFoundAdd方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Value%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.18.</span> <span class="nav-text">Value方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flush%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.19.</span> <span class="nav-text">Flush方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MostAccessed%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.20.</span> <span class="nav-text">*MostAccessed方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#log%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.21.</span> <span class="nav-text">log方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CacheItem%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text">CacheItem类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%BB%93%E6%9E%84-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">类结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NewCacheItem%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.2.</span> <span class="nav-text">NewCacheItem函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KeepAlive%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">KeepAlive方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LifeSpan%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.4.</span> <span class="nav-text">LifeSpan方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AccessedOn%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.5.</span> <span class="nav-text">AccessedOn方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CreateOn%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.6.</span> <span class="nav-text">CreateOn方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AccessCount%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.7.</span> <span class="nav-text">AccessCount方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Key%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.8.</span> <span class="nav-text">Key方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.9.</span> <span class="nav-text">Data方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SetAboutToExpireCallback%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.10.</span> <span class="nav-text">SetAboutToExpireCallback方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AddAboutToExpireCallback%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.11.</span> <span class="nav-text">AddAboutToExpireCallback方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RemoveAboutToExpireCallback%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.12.</span> <span class="nav-text">RemoveAboutToExpireCallback方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-test"><span class="nav-number">4.</span> <span class="nav-text">4.test</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">5.总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tiny Beer"
      src="https://img.imgdb.cn/item/6048d2685aedab222c85ee27.jpg">
  <p class="site-author-name" itemprop="name">Tiny Beer</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpbnliZWVy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tinybeer"><i class="fa fa-fw fa-github"></i>GitHub</span>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-tinybeer"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tiny Beer</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">114k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:44</span>
</div>
  <div class="powered-by">Powered by <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5f2f480c8a8d2b57b594',
      clientSecret: 'ca1d4dab6206dadbfaac987cac186fa57e1b0b21',
      repo        : 'tinybeer.github.io',
      owner       : 'tinybeer',
      admin       : ['tinybeer'],
      id          : 'e7f77496b981537548737f1603f3d162',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
